[["index.html", "User Guide: The ALSroads Package 1 Introduction", " User Guide: The ALSroads Package Ilythia D. Morley, Jean-Romain Roussel 2022-12-01 1 Introduction ALSroads is an R package for correcting, updating, and enhancing vectorial forest road maps using airborne laser scanning (ALS) data. Using a reference map and an ALS point clouds the method – which is described in Roussel et al. (2022) – relocates existing roads to their correct path, measures the width of roads, and assigns a class to each road segment. In the following figure, the red line is the existing road segment recorded and maintained by an authority. This road segment is not associated with any information about the road state, and the road path is inaccurate. The Roussel et al. (2022) method uses the existing road segment as prior information to relocate the road path and derive information about the characteristics of the road. In the example below, the algorithm updated the path of the existing road segment and determined that it is a Class 1 (good state) road with a width of 9 m. The ALSroads package is open source and integrated within the geospatial R ecosystem (i.e., raster and sf). The package utilizes the lidR package, developed for manipulating and visualizing Airborne LiDAR Scanning (ALS) data. This user guide has been written to support users with varying experience working with LiDAR data. Development of the ALSroads package was made possible by the financial support of the Ministère des Forêts, de la Faune et des Parcs du Québec, Canada (MFFP). Testing of the ALSroads package in Ontario was made possible by the Forestry Futures Trust Ontario (Project number: KTTD 2B-2021) and an NSERC Discovery grant (RGPIN-2018-03851), grantee Prof. Nicholas C. Coops. #&gt; &lt;STYLE type=&#39;text/css&#39; scoped&gt; #&gt; PRE.fansi SPAN {padding-top: .25em; padding-bottom: .25em}; #&gt; &lt;/STYLE&gt; #&gt; Reading layer `ctg_extent&#39; from data source `E:\\ALSroads_Guide\\data\\02\\ctg_extent.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 9 features and 34 fields #&gt; Geometry type: POLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `waterbodies&#39; from data source `E:\\ALSroads_Guide\\data\\02\\waterbodies.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 15 features and 13 fields #&gt; Geometry type: MULTIPOLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: -80.08745 ymin: 46.51646 xmax: -80.04824 ymax: 46.53324 #&gt; Geodetic CRS: NAD83 "],["sec-road-extraction-data-requirements.html", "2 Road Extraction Data Requirements 2.1 LiDAR Data 2.2 DTM Data 2.3 Existing Road Network 2.4 Water Bodies (optional)", " 2 Road Extraction Data Requirements The road extraction method, implemented using the ALSroads package, requires three inputs: A LiDAR point cloud in the format of a collection of .las or .laz files. Each file must be spatially indexed with a .lax file (see also the lidR book chapter 18.3). A Digital Terrain Model (DTM) that corresponds to the point cloud collection coverage. This DTM can be generated with lidR (refer to the lidR book chapter 4. A pre-existing vectorial road network (lines), typically in a shapefile or geopackage format. A fourth, optional input can be included to strongly enhance the method. A vectorial map (polygons) of water bodies. 2.1 LiDAR Data Updating and enhancing road segments using ALSroads requires LiDAR data that covers the spatial extent of the roads being updated. For use in the ALSroads package, LiDAR data must be: Non-normalized: to preserve the geometry of the landscape. Spatially indexed: to query areas of interest quickly and improve method performance. Include intensity values: used by the method. In a projected coordinate system and in meters: some parameters are hardcoded in meters. Have a density of 5-10 points/m²: less than 5-10 points/m² and the algorithm is not guaranteed to work; more than 5-10 points/m² is not useful and will increase the computation time. If the density of the input point cloud is over 10 points/m², it can be decimated on-the-fly using the filter argument (see ‘lidR’ book chapter 2.1.1). library(lidR) ctg &lt;- readLAScatalog(&quot;data/03/ctg/&quot;, filter = &quot;-drop_withheld -keep_random_fraction 0.25&quot;) plot(ctg) 2.2 DTM Data Road enhancement using ALSroads requires a Digital Terrain Model (DTM) as an input. DTMs, broadly described as an ‘image’ of the ground, are used for several purposes, including stream flow, basin hydrology, and watershed analysis. The ALSroads method uses a 1-meter resolution DTM to estimate the slopes and roughness of the terrain. For use in the ALSroads package, the input DTM must: Have a resolution of at least 1 m: higher resolution will be downscale on-the-fly. Cover the extent of the LiDAR coverage. Match the coordinate system of the LiDAR coverage. library(raster) dtm &lt;- raster(&quot;path/to/DTM.tif&quot;) plot(ctg) plot(dtm, col = gray(1:50/50), add = T) 2.3 Existing Road Network The road extraction method implemented using ALSroads updates an existing road network. Therefore, an existing network is a critical input. The method will only enhance the roads that are on the existing network. The existing road network must: Be a simple feature (sf) format (line). Match the coordinate system of the LiDAR coverage. library(sf) roads &lt;- st_read(&quot;path/to/roads.shp&quot;, quiet = TRUE) plot(ctg) plot(st_geometry(roads), add = T) 2.4 Water Bodies (optional) An optional input for road extraction using ALSroads is a set of spatial polygons (sf format) of water bodies. An accurate map of water bodies is not necessary to perform the road extraction computation but: It helps to find roads by masking lakes that can easily be interpreted as highly drivable areas because they are perfectly flat, homogeneous, and located in cleared areas. From a geometrical point of view, lakes are the best place to drive a car. Unless the LiDAR point cloud is water classified, there is no way to determine that these flat cleared areas are not passable. Water bodies are required to correctly identify and update roads that cross rivers using bridges. In a DTM, a river is a gap with strong slopes at each edge. These slopes represent an impassable obstacle and cannot be roads. Bridges are visible in the point cloud, but these points must be classified as bridges; otherwise, they have the same status as surrounding points. Geometrically speaking, a bridge in the point cloud is just a set of points above the ground, like trees. Therefore, an unlabeled bridge above a river is similar to a tree above the ground. Providing a map of water bodies enables users to inform the method that the road being updated is known to cross a river. Therefore, the method will allow the passage of a gap (as it appears on the DTM) that would otherwise be considered impassable. If water bodies are included in road extraction (recommended), they must: Be a simple feature (sf) format (polygon). Match the coordinate system of the LiDAR coverage. library(sf) waterbodies &lt;- st_read(&quot;path/to/waterbodies.shp&quot;, quiet = TRUE) #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\03\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N "],["sec-reading-generating-and-plotting-input-data.html", "3 Reading, Generating, and Plotting Input Data 3.1 Reading LiDAR data 3.2 Reading LiDAR data using readLAScatalog 3.3 Reading and Generating DTM Raster Data 3.4 Reading Vector Road Data using st_read()", " 3 Reading, Generating, and Plotting Input Data 3.1 Reading LiDAR data The lidR function readLAS() reads a LAS or LAZ file and returns an object of class LAS. Detailed information on loading LiDAR data using the lidR package can be found in the dedicated lidR vignette. In this user guide, we do not delve deeply into methods for working with ALS data and instead refer interested users to the lidR book. 3.2 Reading LiDAR data using readLAScatalog A LAScatalog is a representation in R of a LAS file or a collection of LAS files. In lidR, the function readLAScatalog() creates an object that represents, in R, a collection of LAS files not loaded in memory. ctg &lt;- readLAScatalog(&quot;path/to/ctg/files&quot;) The print() function can summarize information about the LAScatalog, such as the number and density of points. print(ctg) 3.3 Reading and Generating DTM Raster Data 3.3.1 Reading a raster DTM using raster ALSroads users may be provided with a 1 m resolution DTM that covers the LAScatalog coverage (refer to section 2.2 for DTM requirements). If a 1 m DTM is provided, users can load this information using the raster package. library(raster) dtm &lt;- raster(&quot;path/to/dtm.tif) The loaded DTM can be plotted for visualization using the plot_dtm3d() function from the lidR package. plot_dtm3d(dtm, bg = &quot;white&quot;) 3.3.2 Generating DTM data using rasterize_terrain() ALSroads users that do not have an existing 1 m resolution DTM can produce a DTM using LAS data and the function grid_terrain() from the lidR packages. The rasterize_terrain() function interpolates ground points and creates a DTM. Here we demonstrate the Triangular irregular network (tin) interpolation method. The TIN method is fast, efficient, and generates good DTMs. To generate a 1 m resolution DTM model with the TIN algorithm, we use the rasterize_terrain() function and (1) specify the algorithm using algorithm = tin(), and (2) specify the DTM resolution using res = 1. dtm_tin &lt;- rasterize_terrain(ctg, res = 1, algorithm = tin()) 3.4 Reading Vector Road Data using st_read() An existing road network is required to perform road extraction using ALSroads. Once users have sourced road data (file format = shapefile), the entire road network can be loaded into R using the sf package. The function st_read() reads simple features from a file. Detailed information on the st_read() function and the sf package is available online in a dedicated vignette. roads &lt;- st_read(&quot;path/to/roads&quot;) #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\04\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `updated_roads&#39; from data source `E:\\ALSroads_Guide\\data\\04\\updated_roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 28 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570006.3 ymin: 5151000 xmax: 573000.8 ymax: 5153997 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `road_upd&#39; from data source `E:\\ALSroads_Guide\\data\\04\\road_upd.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 28 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570052.2 ymin: 5152656 xmax: 570434.8 ymax: 5153551 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `road_poly&#39; from data source `E:\\ALSroads_Guide\\data\\04\\road_poly.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 28 fields #&gt; Geometry type: POLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: 570046.7 ymin: 5152650 xmax: 570440.3 ymax: 5153556 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N "],["sec-road-extraction-using-alsroads.html", "4 Road Extraction with ALSroads 4.1 Standard Road Extraction using measure_roads() 4.2 Applying measure_roads() 4.3 Spatial Plotting Updated Roads 4.4 Attribute Plotting Updated Roads", " 4 Road Extraction with ALSroads The ALSroads package includes functions developed for correcting and updating vectorial and topologically valid forest road networks. Using an existing map of road centrelines, the method relocates roads, measures their width, and assigns a class to each road segment Roussel et al. (2022). Broadly, the road extraction method consists of three steps: Production of a raster of conductivity from the point cloud to estimate how easy/difficult it is for an agent to move between two adjacent pixels, using the concept of friction. Low cost (or high conductivity) is attributed to pixels where movement is easy; these pixels are interpreted as those which likely correspond to roads. Application of a least cost path algorithm on the conductivity map to retrieve an accurate geometry of the road centerline in a vector format. This step uses a reference road network maintained by an authority as prior information and updates the geometry of the network. Estimation of road widths and road state using characteristics from the point cloud. Using the accurate geometry returned by step 2, the algorithm extracts the average conductivity of the path and takes successive slices of the point cloud perpendicularly to the road. The slices are used to measure the widths of the roads by detecting variations in the DTM. They are also used to estimate the percentage of points above the measured road, assuming they correspond to vegetation on the road. The state of the road is determined as a combination of the conductivity, drivable width, and percentage of points above the road. Good state roads are assumed to be large, with a low displacement cost and minimal edge vegetation. 4.1 Standard Road Extraction using measure_roads() Here, we explain a standard application of the measure_roads() function. Using a reference road (spatial line), measure_roads() extracts LiDAR information within a buffer of the reference road and computes the exact position of the road. Then, using the updated road shape, road metrics are computed; these include the total width, drivable width, sinuosity, and class. 4.1.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 4.1.2 Input Data As detailed in section 2, the required input data for updating an existing road network are: LAScatalog of LiDAR data Digital Terrain Model (DTM) that corresponds to the LAS catalog coverage Pre-existing road network ctg &lt;- readLAScatalog(&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld -keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads.shp&quot;) Before running the measure_roads() function, users are recommended to: Ensure the coordinate reference system (CRS) of the existing roads network and LAScatalog match. Crop the roads network to the extent of the LAScatalog to confirm that no roads are beyond the extent of the point cloud and DTM. 4.1.3 Network Update The measure_roads() function updates the existing road network by adding eight attributes to the road network: ROADWIDTH - The total width (meters) of the road. DRIVABLEWIDTH - The drivable width (meters) of the road. PERCABOVEROAD - The percentage of points above the road in a range [0.5, 5] m SHOULDERS - The average number of shoulders found along the roads. SINUOSITY - The sinuosity (i.e., curvature) of the road. CONDUCTIVITY - The average conductivity of the road, i.e., how much the road facilitates or impedes movement (unitless) SCORE - The score of the road relates to the quality of the road. Road score ranges from 0 - 100, with a road score of 100 indicating high-quality roads. CLASS - A ‘Class’ (1 - 4) is assigned to each road segment. The class is computed from the SCORE. Class 4 corresponds to a score [0, 25], Class 3 to a score [25, 50], and so on. 4.2 Applying measure_roads() updated_roads &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm) 4.3 Spatial Plotting Updated Roads The updated road network is a spatial feature that can be plotted to visualize the location of updated roads. Following road extraction, the new road width attribute can be used to buffer the road and show the road footprint. Buffering is performed using the sf package function st_buffer(). road_poly &lt;- sf::st_buffer(updated_roads, updated_roads$ROADWIDTH/2) 4.4 Attribute Plotting Updated Roads Information about the quality of roads is beneficial for understanding the characteristics of road networks. Simple plots using the package ggplot2 allow users to complete a preliminary assessment of the updated road network. The number of roads per new road class can be plotted for visualization. ggplot(roads_upd, aes(y = CLASS, fill = CLASS)) + geom_bar() + labs(x=&quot;Count&quot;, y=&quot;Road Class&quot;) + scale_fill_discrete(name = &quot;Road Class&quot;) The drivable widths of roads, grouped by road class, can be plotted for comparison. Only Class 1 and 2 roads are included, as Class 3 and 4 roads do not have updated road widths. ggplot(data=roads_upd_filt, aes(x=CLASS, y= DRIVABL, fill=CLASS)) + geom_boxplot(size = 0.25, color=&quot;black&quot;, coef = 1, outlier.size = 0.5)+ labs(y = &quot;Drivable Road Width (m)&quot;, x = &quot;Road class&quot;)+ theme(text = element_text(size = 16)) + scale_fill_manual(values = c(&quot;#F8766D&quot;, &quot;#7CAE00&quot;), (name = &quot;Road Class&quot;)) "],["sec-standard-parameters.html", "5 Standard Parameters 5.1 Extraction Parameters: 5.2 Embankment Parameters: 5.3 Terrain Parameters (excluding embankment): 5.4 Vegetation: 5.5 Conductivity Parameters: 5.6 Road State Parameters:", " 5 Standard Parameters The meaure_roads() function is built with standard parameters. Users can change these parameters to suit the study areas for which road extraction is being completed. Most standard parameters are not expected to be changed and are suitable for road extraction across different areas. All the measure_roads() parameters are described below, but only the ones in bold should be considered by users. If users need to customize the measure_roads() standard parameters, it is strongly recommended that they read the method source paper. 5.1 Extraction Parameters: Several of the meaure_roads() parameters are used to extract the point cloud, process it into small sections, and compute road profiles. [road_max_len] Default = 2000 m. The maximum size of a processed road section. If a road is longer than this value, it will be split into chunks of equal sizes (each less than the max road length value). The goal of this parameter is to reduce memory usage and computation time and avoid processing a long road without optimization. [road_buffer] Default = 80 m. The width of a buffer around the existing road for point cloud extraction. The algorithm processes only the point cloud within the buffer around the reference roads (see figure below). This value corresponds to the largeest road offset error (i.e., how incorrect the existing road track is) that can be fixed by the method. If the road buffer is 80 m, but a given road is 100 m off the real track, then the real road will be outside the extracted point cloud and won’t be found. If the user knows that the road track error can be up to 100 m, then a road buffer value of 120 m is better suited than the 80 m default value. If the user knows that the maximum road track error is at most 30 m, then a buffer of 40 m will increase computation speed and reduce the chance of producing erroneous results. [road_max_width] Default = 30 m. The maximum width of a road for metrics measurements. Editing the road_buffer distance supports the relocation of the road and minimizes computation time. Once the location of the road is determined, the road edges are generally +/- 10 m from the centerline. No matter the road_buffer distance used, once the proper road centerline is located, the road_max_width is set to 30 m to ensure that the method accurately classifies the road and road edges. [section_length] Default = 10 m. The length of sections of the road for metrics measurements. Roads are divided into sections, and for each section, the road width, road state, and other metrics are computed iteratively by processing slices perpendicular to the road. For example, using the default road section length (10 m), a 500m road will be split into 50 sections. [profile_resolution] Default = 0.5 m. The resolution of the profiles and DTMs for metrics measurements (see Figure 6 in the method paper). 5.2 Embankment Parameters: The meaure_roads() function includes one parameter that specifies how the algorithm deals with embankments in the terrain. [min_slope] Default = 10 degrees. Slope (degrees) greater than the min_slope may initiate or terminate the detection of embankments. For example, if a slope of greater than 10 degrees is encountered on the right or the left of the road centerline, the method will consider this point the road edge. This is illustrated in the figure below. Nice slopes and ditches are expected to be detected to delimitate the road. 5.3 Terrain Parameters (excluding embankment): The meaure_roads() function includes two parameters that specify how the algorithm detects road edges in the terrain aspect, excluding embankment/shoulder (see section 5.2 for embankment parameters). The purpose of these parameters is to allow the algorithm to find the edges of the road, even in the absence of embankments. Classifying the edges of roads using embankments is the preferable method. In the absence of clear embankments, defined by the road edge slopes, the method relies on the DTM complexity of each road section (see section 5.1 for information on road sections) to classify the edges of the road. We refer to the classification of road edges using DTM complexity as the “rescue method” as it is used when the preferred method, based on road embankment, is not possible. The assumptions that support the interpretation of DTM complexity to relocate roads is that roads are flat and not complex. If we remove potential slopes that follow the direction of the road, a road is roughly a 2D strip without variations in height (Z). The edges of a road correspond to the natural landscape and are more complex with a 3D structure and variations on the Z axis. On a given slice perpendicular to the road (see section 5.1 for information on road slices), metrics on the ground points from left to right can be computed to assess the road profile. The road profile is expected to have higher values outside the boundaries of the road and lower or close to zero values inside the boundaries of the road. The road profile frequently resembles the shape of a parabola. Adjusting the method parameters determines the thresholds which define road edges, as illustrated in the figure below. [max_sd_ground_points] Default = 0.1. The LiDAR ground points belonging to roads have a low dispersion on Z profiles because roads are relatively flat (refer to Figure 6 in the method paper). Beyond the boundaries of a road, the standard deviation of ground points starts to increase because the terrain is more complex. This value is a threshold at which the edges of the roads are detected with the rescue method. [max_elevation_ground_points] Default = 0.15. The algorithm normalizes the point cloud relative to the road (i.e., the ground points from a road are expected to be at 0, and the surrounding points are expected to be non-zero). The rescue method uses this property to detect road edges. The embankment method (section 5.2) and rescue method are not mutually exclusive. In many cases, an embankment may be detected on only one side of a road, meaning that the rescue method is used to detect the road edge on the other side. Changing terrain parameters is particularly important when the topography is flat. As the reader can see, a road can be detected, using both methods, based on geometrical features. However, when there is almost nothing to detect (i.e., no embankments and no DTM complexity), the algorithm fails and overestimates the road width. In this situation, decreasing the terrain parameter thresholds will lead to a narrowing of the detected road. 5.4 Vegetation: Once the width of the road is determined (see sections 5.2 and 5.3), the method estimates the drivable road width using the parameter max_percentage_drivable. max_percentage_drivable is the total road width minus the vegetation that impedes road passage. The motivation for this parameter is that while the Slope and DTM can be used to locate a road on the landscape, that road may not be drivable due to vegetation growth. All the LiDAR points located on the road are expected to be ground points. To account for inaccuracies, we assume that 100% of the points on the road must be between 0 and 50 cm. If LiDAR points on the road are above 50 cm, there is vegetation on the road. A single point above 50 cm may be an outline, but a significant percentage of points above this value will trigger a stop signal. Starting from the centerline and going to the left and right, the method computes the cumulative percentage of non-ground points on the road. This produces a ‘threshold-like’ road profile for width measurement (see figure below). [max_percentage_drivable] Default = 0.15. The maximum percentage of LiDAR points above 50 cm (explained above). 5.5 Conductivity Parameters: A key component of the measure_roads() method is the development of a conductivity layer, where pixel values indicate the likelihood that a pixel is or is not drivable. Conductivity parameters correspond to the method used to estimate the overall conductivity layer using multiple sub-conductivity layers. Each layer is described in Figure 3 of the method paper and is activated using an activation function. These activation functions have two thresholds; unless otherwise stated. The values below correspond to these thresholds. It is not recommended for users to change the default values of these parameters. [sigma_min] Default = 0.1. The minimum conductivity layer value cannot be lower than this value. The conductivity layer construction is done such as conductivity values can range from 0 to 1. However, very low values (&lt;0.1) are problematic as they may form a gap in the road and result in a false negative (e.g., the gap may be interpreted as an impassible obstacle). Version 0.2.0 of the ALSroads package (not the one described in the method paper, which is 0.1.0) introduced this parameter to allow the method to cross small gaps in the conductivity layer. [s] Default = c(5, 20). The slope (s) of the terrain indicates where a road cannot be. If the slope of the terrain is greater than the max slope, then a road cannot be present. To avoid binary logic and a hard threshold, a second threshold is introduced at 5° to transform the slope map into a sub-conductivity map using a piecewise-linear activation function. A slope of &lt; 5° has a conductivity of 1; between 5° and 20°, the conductivity decreases linearly to 0, making it impossible to move through pixels with steeper slopes. [r] Default = c(0.05, 0.1). The roughness (r) sub-conductivity layer is based on the assumption that a road surface is anticipated to be a smooth surface in a relatively rough environment. [e] Default = 40. This is a simple threshold activation function. [q] Default = c(0.1, 0.5). Intensity range (q) (difference between the maximum and the minimum) as an estimation of the intensity homogeneity. Rather than using the absolute thresholds, which are not applicable broadly with intensity, we use local and auto-adaptive thresholds based on two percentiles of intensity. Here the 10th and 50th percentiles of intensities are used as threshold values for the activation function. [h] Default = c(0.1, 0.2). The CHM can be interpreted to inform gaps in the canopy. Low CHM (h) values are interpreted to indicate the location of a drivable surface. [d] Default = c(0.25, 0.95). Ground point density values cannot be used directly because of their dependence on the local nominative sampling density. Consequently, we opted for auto-adaptive thresholds based on two percentiles of density (d). [alpha] Default list(h = 1, d = 2, r = 1, i = 1). These are the alpha parameters in equation 1 in the method paper. 5.6 Road State Parameters: Using the measure_roads() function, users classify roads into four classes (see section 4.1.3. These classes are determined using four metrics derived from the point cloud (Figure 7 of the method paper): W - the drivable width of the road, P - the percentage of vegetation points between 0.5 and 5 meters above the road, S - the average number of shoulders detected and, σ - the conductivity per linear meter. An activation function is applied to the four metrics. These activation functions have two parameters. The following are the two parameters of each activation function. Modifying these thresholds has predictable behaviours, but it is hard to quantify them. A simple voting system calculates the weight of each metric (W, P, S, and σ) for determining the road Class. For example, if the method detects a large ‘W’ (drivable width), then this is a ‘vote’ towards the road being a Class 1, but if the ‘P’ (vegetation above the road) value for the road is high, then this is a ‘vote’ for the road being a Class 4 because it appears to be abandoned. Meanwhile, the ‘S’ (average number of shoulders) value for the road may indicate that the road has nice ditches and is well-shaped, which is a ‘vote’ towards the road being a Class 1. Interpreting all these ‘Votes’ facilitates the determination of an overall Class for the road; in this example, the road may be classified as a ‘Class 2’ road. [drivable_width_thresholds] Default c(1, 5). Roads with a drivable road width over 5 m are assigned a score of 100. Roads with a width of less than 1 m are assigned a score of 0. There is a linear relationship between 1 and 5 (i.e., a with of 2 m returns a score of 50%). If a user knows that a road of width 4 m is a good road in their context, we recommend changing the parameter, for example, to c(1, 3). [percentage_veg_thresholds] Default = c(10,40). Roads with a percentage of vegetation (point above ground in a range of [0.5m, 5m]) below 10% are assigned a score of 100%. Roads with a percentage greater than 40% are assigned a score of 0%. There is a linear relationship between the lower and upper percentage vegetation thresholds. [shoulder_thresholds] Default = c(50, 75). For each slice of the road (see ‘section_length’ in section 5.1), the algorithm retains the count of the shoulder/embankments found. For each road, it is possible to find 0, 1, or 2 shoulder/embankments. If the algorithm consistently finds two shoulders (one on the left and one on the right) for each road segment, the road is extremely well-shaped, and we have 100% of the possible count. However, in practice, roads are very rarely shaped well enough that two shoulder/embankments per section can be consistently found. This parameter counts the percentage of shoulders found. A shoulder percentage of 0 % means that the algorithm did not find any shoulders at any road section, and the road is likely poor quality, if a road at all. If 100% of the road shoulders are found, the road is well shaped, and the road score is 100%. If under 50 % of the road shoulders are found for the entire road, the road score is 0%. Changing this parameter is advised if users know that the roads in their study area are not well-shaped by strong ditches. Ultimately users may opt to deactivate this parameter, which is not currently possible but could be done on demand. [conductivity_thresholds] Default = c(0.25, 0.5). If the conductivity of the road is too low (&lt; 0.25), the road score is 0% (see section 5.5). If the conductivity is above 0.5, the score is 100%. The road score between these thresholds is linear. We do not recommend changing this threshold because users do not have control of the conductivity layer, and manipulating this parameter would be done blindly. Once the algorithm calculates a score for each of the four road state parameters, these scores are combined into a final score (Figure 7 of the method paper). This score can be used as is but is also binned in four classes where Class 4 corresponds to a score [0, 25], Class 3 to a score [25, 50], Class 2 to a score [50, 75], and Class 1 to a score [75, 100 ]. #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\01\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 12 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 638000 ymin: 5142000 xmax: 639000 ymax: 5143000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `upd_roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\01\\upd_roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 12 features and 28 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 637998.8 ymin: 5142000 xmax: 639000 ymax: 5142999 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `road&#39; from data source `E:\\ALSroads_Guide\\data\\06\\02\\road.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 36 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 466189.2 ymin: 5363340 xmax: 466723.2 ymax: 5363860 #&gt; Projected CRS: NAD83 / UTM zone 17N #&gt; Reading layer `updated_road&#39; from data source `E:\\ALSroads_Guide\\data\\06\\02\\updated_road.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 44 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 466188.4 ymin: 5363341 xmax: 466718.4 ymax: 5363861 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N + CGVD2013_height_-_CGG2013_-_NAD83_CSRS #&gt; Reading layer `road_upd&#39; from data source `E:\\ALSroads_Guide\\data\\06\\03\\road_upd.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 27 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 648327.4 ymin: 5466091 xmax: 648372.3 ymax: 5466153 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 15N "],["sec-case-studies.html", "6 Case Studies 6.1 Case Study Structure: 6.2 Case Study 1: Low DTM Complexity 6.3 Case Study 2: Road Detection over Water 6.4 Case Study 3: Detecting Narrow Roads 6.5 Case study 4: Detecting a Road Covered by Deciduous Trees", " 6 Case Studies In this section, we present four example applications of the measure_road() function. These case studies are located in different forests where road conditions and landscape characteristics are unique. We provide examples where the measure_road() standard parameters (see section 5) are effective and examples where these parameters may require tuning. Case Study 1: Low DTM Complexity Case Study 2: Road Detection over Water Case Study 3: Narrow Road Detection Case Study 4: Detecting a Road Covered by Deciduous Trees 6.1 Case Study Structure: For each case study, we include code snippets outlining how to: Read the required input data (refer to section 3 for detailed information). Check the Coordinate Reference System (CRS) of the input data and clip the existing road network to the spatial extent of the LAS catalog. Update the existing road network using the measure_roads() function from the ALSroads package. Adjust the standard road extraction parameters to improve method accuracy (see section 5 for information on the standard parameters). Visualize road extraction results. Each case study is ‘stand-alone’, and users do not need to refer to other sections of the user guide. As such, some code snippets, such as loading data, are repeated for each case study. 6.2 Case Study 1: Low DTM Complexity 6.2.1 Overview: The road extraction method developed by Roussel et al. (2022) uses the geometry of the terrain to relocate and measure the roads correctly. Under ideal circumstances, a road is expected to be flat with steep slopes on its edges (shoulders or embankments). The road is embedded within an environment and surrounded by complex and non-flat topography. Under these assumptions, a road is not that hard to find and measure. However, problems arise when there is no geometry to detect. This may happen, for example, if the roads are not shaped with ditches on their sides. In this case, the algorithm is supposed to work with a “rescue method” (see section 5.3) that does not use the shoulders but instead the terrain complexity. Ultimately, if the terrain is perfectly flat, there are no geometrical features that can be used to detect the road. In the following example, we present a method for adjusting the measure_roads() standard parameters to detect roads in a landscape where the topography is almost perfectly flat, roads are not nicely shaped, and standard road extraction is challenging. As the 3D plot of the ground points demonstrates here, the road is easily identifiable, but no geometrical feature can be used to measure it. The road is flat in a flat environment. las &lt;- readLAS(&quot;data/06/01/road_10462.las&quot;) plot(filter_ground(las), bg = &quot;white&quot;) The road extraction method computes a conductivity layer from the point cloud to estimate how easy/difficult it is for an agent to move between two adjacent pixels. Let’s look at the conductivity layer of the road in this case study: sig &lt;- ALSroads::rasterize_conductivity(las, dtm_cs1) #&gt; ........ plot(sig, col = viridis::inferno(50)) As we can see, the conductivity map is perfect. Geometrical features (shoulders or embankments) are not that important to locate the road. Many other features are used, including vegetation and the local density of points. Thus the road centerline will be perfectly relocated even if the road is flat in a flat environment. The measurement of the road width is likely to fail because of the absence of clear geometry (shoulders or embankments). Below we can see a slice of the point cloud perpendicularly to the road. For a better understanding of the figure, users should refer to section 5. The key focus of this figure is the red and green arrows that represent the total road width and the drivable width, respectively. The algorithm has determined the road to be 21 m wide, which is clearly incorrect in this case study. The algorithm overestimates the road width in this case study because the landscape surrounding the road is perfectly flat, and there is nothing to constrain the road width. By altering the default measure_roads() parameter to be more aggressive and less tolerant to various sources of noise, we can relocate the road more accurately. In this specific slice, 6 m is probably a minor underestimation of the actual road width. Users must remember that measurements are performed on numerous consecutive slices and averaged (see section 5.1 for information on road slices). For this specific road, the default parameters result in the road being classified as a 13.6 m wide (total width) ‘Class 2’ road. Once the parameters are adjusted, the road is classified as a 7.6 m (total width) ‘Class 1’ road. The custom parameters result in a road width and road Class more representative of the actual road. If the method classifies the road width as 13.6 m, many points will be found above the road (i.e., vegetation). This interpretation impacts the road classification (see section 5.6) as the method assesses the road as having vegetation on it, which would limit road drivability. However, suppose the actual road width is only 7.6 m. In that case, the algorithm will not find vegetation on the road, as this vegetation is beyond the road edge boundaries, and the road will be determined to be a very clean ‘Class 1’ road. Tuning the `measure_roads()` parameters on a road-by-road basis is impossible and unsuitable for updating extensive forest road networks. Doing so would defeat the method’s purpose, which is automatically updating road networks. Instead of tuning parameters to suit individual roads, users should tune parameters by landscape. In this case study, the custom parameters work well, but the default parameters are generally preferable. It is important to remember that this is an edge case and represents an extreme scenario. 6.2.2 Data, Method, and Application: The following sections present example code and method implementation for adjusting measure_roads() parameters in a low DTM complexity case study. 6.2.2.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.2.2.2 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.2.2.3 Road Extraction and Parameter Tuning: The measure_roads() terrain parameters dictate how the method handles DTM complexity (see section 5.3). The standard terrain parameters are: max_elevation_ground_points: Default = 0.1 max_sd_ground_points: Default = 0.15 In a low DTM complexity area, decreasing the max_elevation_ground_points and max_sd_ground_points improves the accuracy of road extraction. In this case study, we decrease the max_elevation_ground_points to 0.07 and the max_sd_ground_points to 0.04. custom_param = alsroads_default_parameters custom_param$terrain$max_elevation_ground_points = 0.07 custom_param$terrain$max_sd_ground_points = 0.04 updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, param = custom_param) 6.2.3 Results Plotting the updated road network alongside the existing road network allows the visualization of the updated roads. 6.3 Case Study 2: Road Detection over Water 6.3.1 Overview In this case study, we use the measure_roads() function to update a road crossing the Mattagami River (rivière Mattagami) in the Romeo Malette Forest, Ontario. The figure below visualizes the LAS tile used in this example and shows the river on the landscape. las_c &lt;- clip_circle(las, 466200, 5363600, 400) x &lt;- plot(las_c, bg = &quot;white&quot;, size = 3) add_dtm3d(x, dtm) By plotting the road which crosses the Mattagami River on a base map, using the mapView() function, we can see that part of this road is a bridge. For more information on interactive plotting with mapView(), refer to section 7.4.1. 6.3.2 Data, Method, and Application The following sections present example code and method implementation for applying the measure_roads() function to update an existing road that crosses a waterbody. In this case, a bridge crosses the waterbody. If there was no bridge, the method would interpret the waterbody as an impassable obstacle. The measure_roads() standard parameters (see section 5) are sufficient for updating roads that cross bridges. 6.3.2.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.3.2.2 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.3.2.3 Road Extraction: updated_road &lt;- measure_roads(ctg = ctg, roads = road, dtm = dtm) 6.3.3 Results The ability of the meaure_roads() function to update a road that crosses a waterbody and interpret the bridge as part of the road is important for producing a fully connected road network. In this example, the width of the bridge means that there are many points located on it. The algorithm is able to interpret the bridge as a road of Class 1, with an average drivable width of 9.1 m. plot(dtm_cs2) plot(updated_road_cs2[1], add = TRUE) 6.4 Case Study 3: Detecting Narrow Roads 6.4.1 Overview The road extraction method developed by Roussel et al. (2022) is suitable for locating narrow roads. The method locates roads using several road characteristics, including DTM complexity, embankments, and vegetation. Provided that these characteristics are distinct enough to locate the road centerline, the width of the road will not impact the ability of the algorithm to find the road. However, the method parameters do specify that the road width must be over 1 m. A road with a width of less than 1 m is unlikely to be a road that is drivable by standard vehicles. The figure below visualizes a narrow road of 0.8 m in width, which is impacted by vegetation and is not drivable. In this case study, we demonstrate the effectiveness of the measure_roads() function for relocating a narrow road with a drivable road width of 1.2 m. Users can adjust the standard parameters to specify the minimum road width and road buffer (see section 5.1 and 5.6. For example, if a user applies the method in an area where roads must be over 2 m (for a specific vehicle), they can set the minimum road width to 2 m. Or, if users know that in their study area, road centerline inaccuracies are very minimal, they can adjust the road buffer zone to find the correct road centerline within a short distance of the existing centerline, as the figure below visualizes. We update a road in the Dog River-Matawin Forest in Ontario. We do not change the standard parameters in this case study, as they are sufficient for updating narrow roads. The road is narrow and in a generally flat area but can be detected, as the DTM below demonstrates. 6.4.2 Data, Method, and Application The following sections present example code and method implementation applying the measure_roads() function to update a narrow road using standard parameters. 6.4.2.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.4.2.2 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.4.2.3 Road Extraction: The standard measure_roads() parameters are sufficient for updating a narrow road. updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, param = custom_param) 6.4.3 Results The updated road is relocated accurately, and the new road linestring includes information about the state and width of the road, as well as the road curvature, shoulders, and canopy cover. From the results, we can plot the road width and visualize the footprint of the road on the landscape. 6.5 Case study 4: Detecting a Road Covered by Deciduous Trees 6.5.1 Overview In the following example, the road is barely invisible from above because it is completely covered by deciduous trees. Using RGB images or using a CHM, it is impossible to find and measure the road. The ALSroads uses multiple inputs to locate roads (i.e., DTM, CHM, density of ground points, etc.) and does not rely exclusively on the CHM to find the road. Therefore, even a road totally covered by deciduous trees can be located. In this specific case study, the road is visible in the DTM. It is also visible in the density of ground points. Overall, the road is visible in LiDAR data, even if some indicators, such as the CHM, cannot be used independently to locate the road. Therefore, this edge case works ‘out-of-the-box’ and the conductivity layer effectively highlights the road on the landscape, despite the road being covered by deciduous trees. Using the measure_road() function the road is properly located and measured ‘out-of-the-box’ with standard parameters (see section 5. The road is particularly well-shaped and measuring its width (total and drivable) is not a problem. Here, the algorithm measured an 8.6 m ‘Class 1’ road. In the image below, we can see in purple the original inaccurate track of the official map and in yellow the new track with additional attributes. 6.5.2 Data, Method, and Application The following sections present example code and method implementation applying the measure_roads() function to update a road covered by deciduous trees. 6.5.2.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.5.2.2 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.5.2.3 Road Extraction: The standard measure_roads() parameters are sufficient for updating the road in the case study. updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, param = custom_param) 6.5.3 Results: Despite being covered by deciduous trees the updated road is relocated accurately and includes information on the road width. From the results, we can plot the road and visualize the footprint of the road on the dense deciduous forest landscape. #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\08\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `updated_roads&#39; from data source `E:\\ALSroads_Guide\\data\\08\\updated_roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 28 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570006.3 ymin: 5151000 xmax: 573000.8 ymax: 5153997 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N "],["sec-tips-and-tricks.html", "7 Tips and Tricks 7.1 Casting Roads to Linestring 7.2 Adding an ID Column 7.3 Selecting Specific Roads 7.4 Plotting Data 7.5 Saving Data 7.6 Reconnecting Roads 7.7 RStudio Shortcuts", " 7 Tips and Tricks Following the update of road segments using the ALSroads package, users may wish to edit data, filter results, or plot outcomes. Here, we include code snippets to provide users with basic data manipulation and interpretation tools. In the following sections, users are recommended to refer to the package manuals for additional information. When using functions in R users can type ?function_name() into the R console to find information about the input data requireed, and example applications or that function. For example, running ?measure_roads() in the console will bring up information about the function. 7.1 Casting Roads to Linestring Existing road networks may be multistring features; the measure_roads() function requires that roads are linestrings. Changing multistring features to linestrings requires the st_cast() function from the sf package (refer to the sf vignette for detailed information). library(&quot;sf&quot;) roads &lt;- st_cast(roads, &quot;LINESTRING&quot;) 7.2 Adding an ID Column Existing road networks frequently include FID and ID columns that help users select individual roads. In some cases, however, road networks have been edited or updated, and the ID/FID columns are missing information. Users may wish to add a new ID column that relates explicitly to the roads on which the ALSroads method is applied. In that case, users can add and populate a new column using the rowid_to_column function from the tibble package (refer to the tibble vignette for detailed information). library(&quot;tribble&quot;) roads &lt;- tibble::rowid_to_column(roads, &quot;NEW_ID&quot;) 7.3 Selecting Specific Roads Users may wish to update only selected roads from the existing road network, not the entire network. Users can select specific roads using the filter function from the dplyr package (refer to the dplyr vignette for detailed information). Users can select roads using an ID column where row values are unique. In this case, we use the “NEW_ID” column (see section 7.2). Users can select a single road: library(&quot;dplyr&quot;) road_subset &lt;- roads %&gt;% dplyr::filter(NEW_ID %in% c(10)) Multiple roads: library(&quot;dplyr&quot;) road_subset &lt;- roads %&gt;% dplyr::filter(NEW_ID %in% c(5,10,15)) Or, a series of roads (all roads between 10 and 50 will be selected): library(&quot;dplyr&quot;) road_subset &lt;- roads %&gt;% dplyr::filter(NEW_ID %in% c(10:50)) 7.4 Plotting Data 7.4.1 Interactive Spatial Plotting with mapView(): Users working within R can produce interactive spatial plots using the function mapView() from the package mapview(refer to the mapview vignette). The mapView() function produces an interactive view of spatial object(s) on top of a base map. library(&quot;mapview&quot;) library(&quot;leaflet&quot;) url = &quot;https://servicesmatriciels.mern.gouv.qc.ca:443/erdas-iws/ogc/wmts/Inventaire_Ecoforestier/Inventaire_Ecoforestier/default/GoogleMapsCompatibleExt2:epsg:3/{z}/{y}/{x}.jpg&quot; m &lt;- mapview::mapview(list(existing_road, updated_road), layer.name = c(&quot;Existing&quot;, &quot;Updated&quot;), color = c(&quot;red&quot;, &quot;blue&quot;), map.type = &quot;Esri.WorldImagery&quot;) leaflet::addTiles(m@map, url) 7.4.2 Spatial Plotting with plot(): For generic plotting, users can use the plot() function, which is included in base R. plot(updated_road[1]) #[1] specifies that only the first attribute will plot 7.4.3 Plotting with ggplot(): ggplot2 is a plotting package that supports the creation of complex plots. ggplot2 is commonly used, in R, to produce publication-quality plots. For detailed information on using ggplot2, we recommend users refer to the ggplot2 website. See section 4.4 for more examples of plotting road attributes using ggplot2. library(&quot;ggplot2&quot;) ggplot(data=updated_roads, aes(x=CLASS, y= SCORE, fill=CLASS)) + geom_boxplot(size = 0.25, color=&quot;black&quot;, coef = 1, outlier.size = 0.5)+ labs(y = &quot;Road Score&quot;, x = &quot;Road class&quot;)+ theme(text = element_text(size = 16)) 7.4.4 Plotting LiDAR data: The lidR package takes advantage of the rgl package to provide an interactive 3D viewer with points coloured by Z coordinates. The lidR package provides several functions for plotting LiDAR data, that include: overlay plotting and tree-top plotting. We strongly recommend that users interested in plotting LiDAR data refer to the lidR book. library(&quot;lidR&quot;) plot(las) 7.4.5 3D Plotting Raster Data: rayshader is an open source package for producing 2D and 3D data visualizations in R. rayshader uses elevation data in a base R matrix and a combination of raytracing, hillshading algorithms, and overlays to generate 2D and 3D maps (refer to the rayshader website for more information). library(rayshader) elmat &lt;- raster_to_matrix(dtm) map &lt;- elmat %&gt;% sphere_shade(texture = &quot;imhof1&quot;, progbar = FALSE) %&gt;% add_water(detect_water(elmat), color = &quot;imhof1&quot;) %&gt;% add_shadow(ray_shade(elmat, progbar = FALSE), 0.5) %&gt;% add_shadow(ambient_shade(elmat, progbar = FALSE), 0) plot_3d(map, elmat, zscale = 20, windowsize = c(800, 800)) 7.5 Saving Data Following the extraction of roads from an ALS point cloud and the update of the existing road network, users will need to save the new network as a file that can be opened in R and other GIS programs, such as ArcGIS. To save simple features (lines and polygons), users can use the ‘st_write’ function from the ‘sf’ package (refer to the sf vignette for detailed information). library(&quot;sf&quot;) st_write(road_subset, &quot;path/to/folder/roads_subset.shp&quot;) If users have produced raster data files while working with ALSroads, for example a DTM. In that case, this data can be saved using the writeRaster function from the raster package (refer to the raster manual for detailed information). library(&quot;raster&quot;) writeRaster(DTM, &quot;path/to/folder/DTM.tif&quot;, format = &quot;GTiff&quot;) 7.6 Reconnecting Roads The updated road network will include all of the roads in the existing road network. However, because the method relocates each road, the updated network may appear disconnected, with road ends no longer perfectly aligning. The st_snap_lines() function was added to the ALSroads package to address this and ensure that the updated road network is topologically valid. This post-processing step involves the “snapping” of road ends together, with or without prior knowledge of road connections. If users provide the existing road network to the st_snap_lines(), the connection of roads will be more accurate. Users can also specify tolerance (distance) between two roads where snapping will occur. library(&quot;ALSroads&quot;) snapped_roads &lt;- st_snap_lines(roads = updated_roads, ref = existing_roads, field = &quot;NEW_ID&quot;, tolerance = 30) library(&quot;mapview&quot;) library(&quot;leaflet&quot;) url &lt;- &quot;https://servicesmatriciels.mern.gouv.qc.ca:443/erdas-iws/ogc/wmts/Inventaire_Ecoforestier/Inventaire_Ecoforestier/default/GoogleMapsCompatibleExt2:epsg:3/{z}/{y}/{x}.jpg&quot; m &lt;- mapview::mapview(list(updated_roads_, snapped_roads$roads), layer.name = c(&quot;Snapped&quot;, &quot;Updated&quot;), color = c(&quot;green&quot;, &quot;red&quot;), lwd = c(3, 1.5), map.type = &quot;Esri.WorldImagery&quot;) leaflet::addTiles(m@map, url) Other post-processing functions included in the ALSroads package are: check_road_differences: Check the amplitude of differences between corrected and uncorrected roads. st_check_crossings: Check if roads cross at points other than at their ends. st_check_junctions: Check if road endings are close enough to be considered potential junctions. 7.7 RStudio Shortcuts ctrl+shift+C: Comment lines in and out. alt + -: Shortcut for &lt;- . ctrl-1 and crtl-2: Shift the cursor focus to script or console, respectively. ctrl-shift-d: Duplicate the current line or selected text. ctrl-shift-arrow: Highlight chunks of text. ctrl-D: Delete Line. alt+shift+K: View and edit keyboard shortcuts. #&gt; &lt;STYLE type=&#39;text/css&#39; scoped&gt; #&gt; PRE.fansi SPAN {padding-top: .25em; padding-bottom: .25em}; #&gt; &lt;/STYLE&gt; "],["sec-getting-started-with-r.html", "8 Getting Started with R 8.1 Installing R and RStudio 8.2 Installing ALSroads", " 8 Getting Started with R 8.1 Installing R and RStudio ALSroads is an R package and requires an installation of the R programming language that can be downloaded for Windows, macOS, and Linux. The R language is usually used using an integrated development environment (IDE). RStudio is the most famous IDE for R and is available for download online. Several tutorials detailing the initial setup and introduction to R are available online: An Introduction to R Introduction to Data Science R Tutorial: a quick beginner’s guide to using R R Packages: A Beginner’s Tutorial 8.2 Installing ALSroads ALSroads is available on Github but is not part of the available packages on CRAN. To install ALSroads, you must first install the package remotes and then use remotes to install the ALSroads package from Github. install.packages(&quot;remotes&quot;) remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) "],["sec-team.html", "9 Project Team Members", " 9 Project Team Members ALSroads was developed by Jean-Romain Roussel for road extraction in forested regions and has been tested and validated in Quebec and Ontario. A comprehensive explanation of the road extraction method is available in Roussel et al. (2022), as well as results from the method implementation in Quebec. The method has been validated for two forest management units in Ontario. The development and testing of the road extraction method and the ALSroads package would not be possible without dedicated collaborators. Jean-Romain Roussel [Method Author and Developer] Ilythia D. Morley [Project Coordinator] is the project coordinator for this project to facilitate communication, data transfers, and product testing. Professor Nicholas Coops [Project Lead] holds a Canada Research Chair in Remote Sensing (Tier 1) at UBC. He has published &gt;460 total referenced peer-reviewed journal publications and is internationally recognized as a scientific leader in the field of remote sensing. He was the principal investigator of the AWARE project; a 5-year research project focused on developing LIDAR applications in Canada for forestry applications. He is a co-author on the Canadian Forest Service LIDAR best practice guide series, the most downloaded CFS information handbook ever, focused on LIDAR data processing. In 2020, he was the co-receipt of the Marcus Wallenberg prize for scientific achievements contributing to significantly broadening knowledge and technical development within the field of Forestry. Professor Alexis Achim [Project Lead] is the Director of Laval University’s Renewable Materials Research Centre. He has developed expertise in the field of wood resource assessment and participated in AWARE, a Canada-wide project on using ALS to predict wood fibre resource attributes. The R package ‘lidR’, which is extensively used in the ALS international research community, was developed in his lab as part of the work done for this project. He is currently a lead investigator of a new 5-year, $CAD 5 million research project (Silva21) developing new silvicultural approaches and technologies for the Canadian Forest industries. Antoine Leboeuf [Team Member] Ministère des Forêts, de la Faune et des Parcs (MFFP) Jean-Francois Bourdon [Team Member] Ministère des Forêts, de la Faune et des Parcs (MFFP) Professor Jeff Dech [Team Member] is chair of the Department of Biology and Chemistry at Nipissing University. He previously held an Industrial Research Chair in Forest Bioproducts supported by Tembec and was a co-investigator on the AWARE project. He has developed a research program focused on the use of site classification and stand structure data derived from remote sensing to describe and predict forest growth and quality over broad spatial scales. This work has focused on Ecological Land Classification and LiDAR-derived predictors and has involved the establishment of extensive networks of field plots and intensive sampling campaigns as part of several collaborative projects in the Boreal and Great-Lakes St. Lawrence forests. Douglas E.B. Reid [Team Member] is the Boreal Silviculture Research Program Lead at the Centre for Northern Forest Ecosystem Research in Thunder Bay. His research has developed tools to evaluate the accuracy of remote sensing approaches to silviculture monitoring and is developing tools to evaluate stand height as a measure of growth performance in regenerating stands using single photon LiDAR. He has knowledge of the importance of roads and their extreme variability from conducting previous work examining caribou habitat conditions within managed and unmanaged forests in Ontario. Mr. Grant McCartney [Team Member] is an analyst at Forsite, and formally acted as a spatial analyst and forest information systems coordinator with Rayonier Advanced Materials (RYAM) Forest Management. He performs spatial analysis in support of forest management planning (FMP) and forestry operations on the Gordon Cosens, Romeo Malette and Martel – Magpie Forests in Northeastern Ontario, Canada. Grant is a member of the Forest Information Data Advisory Group (FIDAG) and Provincial Forest Inventory Advisory Committee (PFIAC) MNRF committees working to improve the quality of spatial forest information in the province. Scott McPherson [Team Member] is the planning forester and analyst for the Nipissing and Sudbury Forests of central Ontario, reporting to Nipissing Forest Resource Management Inc and the Vermilion Forest Management Company, Ltd. Scott has worked in the government and industry sectors for 25 years, focusing on growth &amp; Yield, silviculture, and planning. Lauren Quist [Team Member] is an analyst and planner at Hearst Forest Management Inc and formally worked as a contractor for the MNFR. Lauren assists in preparing 10-year forest management plans is a certified Photo-Interpreter for the Boreal Forest and Great Lakes - St.L. Forest and works with FRI and LiDAR data to produce timber volume estimates. In her current role, Lauren’s responsibilities include producing FSC documentation &amp; products (e.g. update Gap Analysis, HCV, caribou strategy), caribou habitat &amp; disturbance analysis, and the preparation of annual forest management reports. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
