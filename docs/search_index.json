[["index.html", "User Guide: The ALSroads Package 1 Introduction", " User Guide: The ALSroads Package Ilythia D. Morley, Jean-Romain Roussel 2022-11-23 1 Introduction ALSroads is an R package for correcting, updating, and enhancing vectorial forest road maps using airborne laser scanning (ALS) data. Using a reference map and an ALS point clouds the method – which is described in Roussel et al. (2022) – relocates existing roads to their correct path, measures the width of roads, and assigns a class to each road segment. In the following figure, the red line is the existing road segment recorded and maintained by an authority. This road segment is not associated with any information about the road state, and the road path is inaccurate. The Roussel et al. (2022) method uses the existing road segment as prior information to relocate the road path and derive information about the characteristics of the road. In the example below, the algorithm updated the path of the existing road segment and determined that it is a Class 1 (good state) road with a width of 9 m. The ALSroads package is open source and integrated within the geospatial R ecosystem (i.e., raster and sf). The package utilizes the lidR package, developed for manipulating and visualizing Airborne LiDAR Scanning (ALS) data. This user guide has been written to support users with varying experience working with LiDAR data. Development of the ALSroads package was made possible by the financial support of the Ministère des Forêts, de la Faune et des Parcs du Québec, Canada (MFFP). Testing of the ALSroads package in Ontario was made possible by the Forestry Futures Trust Ontario (Project number: KTTD 2B-2021) and an NSERC Discovery grant (RGPIN-2018-03851), grantee Prof. Nicholas C. Coops. ## &lt;STYLE type=&#39;text/css&#39; scoped&gt; ## PRE.fansi SPAN {padding-top: .25em; padding-bottom: .25em}; ## &lt;/STYLE&gt; ## Reading layer `ctg_extent&#39; from data source `E:\\ALSroads_Guide\\data\\03\\ctg_extent.shp&#39; using driver `ESRI Shapefile&#39; ## Simple feature collection with 9 features and 34 fields ## Geometry type: POLYGON ## Dimension: XY ## Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 ## Projected CRS: NAD83(CSRS) / UTM zone 17N "],["sec-road-extraction-data-requirements.html", "2 Road Extraction Data Requirements 2.1 LiDAR Data 2.2 DTM Data 2.3 Existing Road Network 2.4 Water Bodies (optional)", " 2 Road Extraction Data Requirements The road extraction method, implemented using the ALSroads package, requires three inputs: A LiDAR point cloud in the format of a collection of .las or .laz files. Each file must be spatially indexed with a .lax file (see also the lidR book chapter 18.3). A Digital Terrain Model (DTM) that corresponds to the point cloud collection coverage. This DTM can be generated with lidR (refer to the lidR book chapter 4. A pre-existing vectorial road network (lines), typically in a shapefile or geopackage format. A fourth, optional input can be included to strongly enhance the method. A vectorial map (polygons) of water bodies. 2.1 LiDAR Data Updating and enhancing road segments using ALSroads requires LiDAR data that covers the spatial extent of the roads being updated. For use in the ALSroads package, LiDAR data must be: Non-normalized: to preserve the geometry of the landscape. Spatially indexed: to query areas of interest quickly and improve method performance. Include intensity values: used by the method. In a projected coordinate system and in meters: some parameters are hardcoded in meters. Have a density of 5-10 points/m²: less than 5-10 points/m² and the algorithm is not guaranteed to work; more than 5-10 points/m² is not useful and will increase the computation time. If the density of the input point cloud is over 10 points/m², it can be decimated on-the-fly using the filter argument (see ‘lidR’ book chapter 2.1.1). library(lidR) ctg &lt;- readLAScatalog(&quot;data/03/ctg/&quot;, filter = &quot;-drop_withheld -keep_random_fraction 0.25&quot;) plot(ctg) 2.2 DTM Data Road enhancement using ALSroads requires a Digital Terrain Model (DTM) as an input. DTMs, broadly described as an ‘image’ of the ground, are used for several purposes, including stream flow, basin hydrology, and watershed analysis. The ALSroads method uses a 1-meter resolution DTM to estimate the slopes and roughness of the terrain. For use in the ALSroads package, the input DTM must: Have a resolution of at least 1 m: higher resolution will be downscale on-the-fly. Cover the extent of the LiDAR coverage. Match the coordinate system of the LiDAR coverage. library(raster) dtm &lt;- raster(&quot;data/03/DTM.tif&quot;) plot(ctg) plot(dtm, col = gray(1:50/50), add = T) 2.3 Existing Road Network The road extraction method implemented using ALSroads updates an existing road network. Therefore, an existing network is a critical input. The method will only enhance the roads that are on the existing network. The existing road network must: Be a simple feature (sf) format (line). Match the coordinate system of the LiDAR coverage. library(sf) roads &lt;- st_read(&quot;data/03/roads.shp&quot;, quiet = TRUE) plot(ctg) plot(st_geometry(roads), add = T) 2.4 Water Bodies (optional) An optional input for road extraction using ALSroads is a set of spatial polygons (sf format) of water bodies. An accurate map of water bodies is not necessary to perform the road extraction computation but: It helps to find roads by masking lakes that can easily be interpreted as highly drivable areas because they are perfectly flat, homogeneous, and located in cleared areas. From a geometrical point of view, lakes are the best place to drive a car. Unless the LiDAR point cloud is water classified, there is no way to determine that these flat cleared areas are not passable. Water bodies are required to correctly identify and update roads that cross rivers using bridges. In a DTM, a river is a gap with strong slopes at each edge. These slopes represent an impassable obstacle and cannot be roads. Bridges are visible in the point cloud, but these points must be classified as bridges; otherwise, they have the same status as surrounding points. Geometrically speaking, a bridge in the point cloud is just a set of points above the ground, like trees. Therefore, an unlabeled bridge above a river is similar to a tree above the ground. Providing a map of water bodies enables users to inform the method that the road being updated is known to cross a river. Therefore, the method will allow the passage of a gap (as it appears on the DTM) that would otherwise be considered impassable. If water bodies are included in road extraction (recommended), they must: Be a simple feature (sf) format (polygon). Match the coordinate system of the LiDAR coverage. library(sf) waterbodies &lt;- st_read(&quot;data/03/waterbodies.shp&quot;, quiet = TRUE) #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\03\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N "],["sec-reading-generating-and-plotting-input-data.html", "3 Reading, Generating, and Plotting Input Data 3.1 Reading LiDAR data 3.2 Reading LiDAR data using readLAScatalog 3.3 Reading and Generating DTM Raster Data 3.4 Reading Vector Road Data using st_read()", " 3 Reading, Generating, and Plotting Input Data 3.1 Reading LiDAR data The lidR function readLAS() reads a LAS or LAZ file and returns an object of class LAS. Detailed information on loading LiDAR data using the lidR package can be found in the dedicated lidR vignette. In this user guide, we do not delve deeply into methods for working with ALS data and instead refer interested users to the lidR book. 3.2 Reading LiDAR data using readLAScatalog A LAScatalog is a representation in R of a LAS file or a collection of LAS files. In lidR, the function readLAScatalog() creates an object that represents, in R, a collection of LAS files not loaded in memory. ctg &lt;- readLAScatalog(&quot;path/to/ctg/files&quot;) The print() function can summarize information about the LAScatalog, such as the number and density of points. print(ctg) #&gt; class : LAScatalog (v1.4 format 6) #&gt; extent : 570000, 573000, 5151000, 5154000 (xmin, xmax, ymin, ymax) #&gt; coord. ref. : NAD83(CSRS) / UTM zone 17N #&gt; area : 9 km² #&gt; points : 417.7 million points #&gt; density : 46.4 points/m² #&gt; density : 34.8 pulses/m² #&gt; num. files : 9 3.3 Reading and Generating DTM Raster Data 3.3.1 Reading a raster DTM using raster ALSroads users may be provided with a 1 m resolution DTM that covers the LAScatalog coverage (refer to section 2.2 for DTM requirements). If a 1 m DTM is provided, users can load this information using the raster package. library(raster) dtm &lt;- raster(&quot;path/to/dtm.tif) The loaded DTM can be plotted for visualization using the plot_dtm3d() function from the lidR package. plot_dtm3d(dtm, bg = &quot;white&quot;) 3.3.2 Generating DTM data using rasterize_terrain() ALSroads users that do not have an existing 1 m resolution DTM can produce a DTM using LAS data and the function grid_terrain() from the lidR packages. The rasterize_terrain() function interpolates ground points and creates a DTM. Here we demonstrate the Triangular irregular network (tin) interpolation method. The TIN method is fast, efficient, and generates good DTMs. To generate a 1 m resolution DTM model with the TIN algorithm, we use the rasterize_terrain() function and (1) specify the algorithm using algorithm = tin(), and (2) specify the DTM resolution using res = 1. dtm_tin &lt;- rasterize_terrain(ctg, res = 1, algorithm = tin()) 3.4 Reading Vector Road Data using st_read() An existing road network is required to perform road extraction using ALSroads. Once users have sourced road data (file format = shapefile), the entire road network can be loaded into R using the sf package. The function st_read() reads simple features from a file. Detailed information on the st_read() function and the sf package is available online in a dedicated vignette. roads &lt;- st_read(&quot;path/to/roads&quot;) url = &quot;https://servicesmatriciels.mern.gouv.qc.ca:443/erdas-iws/ogc/wmts/Inventaire_Ecoforestier/Inventaire_Ecoforestier/default/GoogleMapsCompatibleExt2:epsg:3/{z}/{y}/{x}.jpg&quot; m = mapview::mapview(roads, layer.name = &quot;Road Segments&quot;, color = &quot;red&quot;, map.type = &quot;Esri.WorldImagery&quot;) leaflet::addTiles(m@map, url) #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\04\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `updated_roads&#39; from data source `E:\\ALSroads_Guide\\data\\04\\updated_roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 28 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570006.3 ymin: 5151000 xmax: 573000.8 ymax: 5153997 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `road_upd&#39; from data source `E:\\ALSroads_Guide\\data\\04\\road_upd.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 28 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570052.2 ymin: 5152656 xmax: 570434.8 ymax: 5153551 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `road_poly&#39; from data source `E:\\ALSroads_Guide\\data\\04\\road_poly.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 28 fields #&gt; Geometry type: POLYGON #&gt; Dimension: XY #&gt; Bounding box: xmin: 570046.7 ymin: 5152650 xmax: 570440.3 ymax: 5153556 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N "],["sec-road-extraction-using-alsroads.html", "4 Road Extraction with ALSroads 4.1 Standard Road Extraction using measure_roads() 4.2 Applying measure_roads() 4.3 Spatial Plotting Updated Roads 4.4 Attribute Plotting Updated Roads", " 4 Road Extraction with ALSroads The ALSroads package includes functions developed for correcting and updating vectorial and topologically valid forest road networks. Using an existing map of road centrelines, the method relocates roads, measures their width, and assigns a class to each road segment Roussel et al. (2022). Broadly, the road extraction method consists of three steps: Production of a raster of conductivity from the point cloud to estimate how easy/difficult it is for an agent to move between two adjacent pixels, using the concept of friction. Low cost (or high conductivity) is attributed to pixels where movement is easy; these pixels are interpreted as those which likely correspond to roads. Application of a least cost path algorithm on the conductivity map to retrieve an accurate geometry of the road centerline in a vector format. This step uses a reference road network maintained by an authority as prior information and updates the geometry of the network. Estimation of road widths and road state using characteristics from the point cloud. Using the accurate geometry returned by step 2, the algorithm extracts the average conductivity of the path and takes successive slices of the point cloud perpendicularly to the road. The slices are used to measure the widths of the roads by detecting variations in the DTM. They are also used to estimate the percentage of points above the measured road, assuming they correspond to vegetation on the road. The state of the road is determined as a combination of the conductivity, drivable width, and percentage of points above the road. Good state roads are assumed to be large, with a low displacement cost and minimal edge vegetation. 4.1 Standard Road Extraction using measure_roads() Here, we explain a standard application of the measure_roads() function. Using a reference road (spatial line), measure_roads() extracts LiDAR information within a buffer of the reference road and computes the exact position of the road. Then, using the updated road shape, road metrics are computed; these include the total width, drivable width, sinuosity, and class. 4.1.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 4.1.2 Input Data As detailed in section 2, the required input data for updating an existing road network are: LAScatalog of LiDAR data Digital Terrain Model (DTM) that corresponds to the LAS catalog coverage Pre-existing road network ctg &lt;- readLAScatalog(&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld -keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads.shp&quot;) Before running the measure_roads() function, users are recommended to: Ensure the coordinate reference system (CRS) of the existing roads network and LAScatalog match. Crop the roads network to the extent of the LAScatalog to confirm that no roads are beyond the extent of the point cloud and DTM. 4.1.3 Network Update The measure_roads() function updates the existing road network by adding eight attributes to the road network: ROADWIDTH - The total width (meters) of the road. DRIVABLEWIDTH - The drivable width (meters) of the road. PERCABOVEROAD - The percentage of points above the road in a range [0.5, 5] m SHOULDERS - The average number of shoulders found along the roads. SINUOSITY - The sinuosity (i.e., curvature) of the road. CONDUCTIVITY - The average conductivity of the road, i.e., how much the road facilitates or impedes movement (unitless) SCORE - The score of the road relates to the quality of the road. Road score ranges from 0 - 100, with a road score of 100 indicating high-quality roads. CLASS - A ‘Class’ (1 - 4) is assigned to each road segment. The class is computed from the SCORE. Class 4 corresponds to a score [0, 25], Class 3 to a score [25, 50], and so on. 4.2 Applying measure_roads() In this example, we do not include water bodies, refer to section 7 for an example application with water bodies. Similarly, here we do not adjust the ALSroads default parameters; refer to section 6 applications of the method with custom parameters. updated_roads &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm) 4.3 Spatial Plotting Updated Roads The updated road network is a spatial feature that can be plotted to visualize the location of updated roads. url = &quot;https://servicesmatriciels.mern.gouv.qc.ca:443/erdas-iws/ogc/wmts/Inventaire_Ecoforestier/Inventaire_Ecoforestier/default/GoogleMapsCompatibleExt2:epsg:3/{z}/{y}/{x}.jpg&quot; m &lt;- mapview::mapview(list(roads, roads_upd), layer.name = c(&quot;Inaccurate&quot;, &quot;Corrected&quot;), color = c(&quot;red&quot;, &quot;blue&quot;), map.type = &quot;Esri.WorldImagery&quot;) leaflet::addTiles(m@map, url) Following road extraction, the new road width attribute can be used to buffer the road and show the road footprint. Buffering is performed using the sf package function st_buffer(). road_poly &lt;- sf::st_buffer(updated_roads, updated_roads$ROADWIDTH/2) url &lt;- &quot;https://servicesmatriciels.mern.gouv.qc.ca:443/erdas-iws/ogc/wmts/Inventaire_Ecoforestier/Inventaire_Ecoforestier/default/GoogleMapsCompatibleExt2:epsg:3/{z}/{y}/{x}.jpg&quot; m &lt;- mapview::mapview(list(road_upd, road_poly), layer.name = c(&quot;Corrected Road&quot;, &quot;Road Width Buffer&quot;), col.regions=list(&quot;blue&quot;,&quot;orange&quot;),col=list(&quot;blue&quot;,&quot;orange&quot;), map.type = &quot;Esri.WorldImagery&quot;) leaflet::addTiles(m@map, url) 4.4 Attribute Plotting Updated Roads Information about the quality of roads is beneficial for understanding the characteristics of road networks. Simple plots using the package ggplot2 allow users to complete a preliminary assessment of the updated road network. The number of roads per new road class can be plotted for visualization. ggplot(roads_upd, aes(y = CLASS, fill = CLASS)) + geom_bar() + labs(x=&quot;Count&quot;, y=&quot;Road Class&quot;) + scale_fill_discrete(name = &quot;Road Class&quot;) The drivable widths of roads, grouped by road class, can be plotted for comparison. Only Class 1 and 2 roads are included, as Class 3 and 4 roads do not have updated road widths. ggplot(data=roads_upd_filt, aes(x=CLASS, y= DRIVABL, fill=CLASS)) + geom_boxplot(size = 0.25, color=&quot;black&quot;, coef = 1, outlier.size = 0.5)+ labs(y = &quot;Drivable Road Width (m)&quot;, x = &quot;Road class&quot;)+ theme(text = element_text(size = 16)) + scale_fill_manual(values = c(&quot;#F8766D&quot;, &quot;#7CAE00&quot;), (name = &quot;Road Class&quot;)) "],["sec-standard-parameters.html", "5 Standard Parameters 5.1 Extraction Parameters: 5.2 Embankment Parameters: 5.3 Terrain Parameters (excluding embankment): 5.4 Vegetation: 5.5 Conductivity Parameters: 5.6 Road State Parameters:", " 5 Standard Parameters The meaure_roads() function is built with standard parameters. Users can change these parameters to suit the study areas for which road extraction is being completed. Most standard parameters are not expected to be changed and are suitable for road extraction across different areas. All the measure_roads() parameters are described below, but only the ones in bold should be considered by users. If users need to customize the measure_roads() standard parameters, it is strongly recommended that they read the method source paper. 5.1 Extraction Parameters: Several of the meaure_roads() parameters are used to extract the point cloud, process it into small sections, and compute road profiles. [road_max_len] Default = 2000 m. The maximum size of a processed road section. If a road is longer than this value, it will be split into chunks of equal sizes (each less than the max road length value). The goal of this parameter is to reduce memory usage and computation time and avoid processing a long road without optimization. [road_buffer] Default = 80 m. The width of a buffer around the existing road for point cloud extraction. The algorithm processes only the point cloud within the buffer around the reference roads (see figure below). This value corresponds to the largeest road offset error (i.e., how incorrect the existing road track is) that can be fixed by the method. If the road buffer is 80 m, but a given road is 100 m off the real track, then the real road will be outside the extracted point cloud and won’t be found. If the user knows that the road track error can be up to 100 m, then a road buffer value of 120 m is better suited than the 80 m default value. If the user knows that the maximum road track error is at most 30 m, then a buffer of 40 m will increase computation speed and reduce the chance of producing erroneous results. [road_max_width] Default = 30 m. The maximum width of a road for metrics measurements. Editing the road_buffer distance supports the relocation of the road and minimizes computation time. Once the location of the road is determined, the road edges are generally +/- 10 m from the centerline. No matter the road_buffer distance used, once the proper road centerline is located, the road_max_width is set to 30 m to ensure that the method accurately classifies the road and road edges. [section_length] Default = 10 m. The length of sections of the road for metrics measurements. Roads are divided into sections, and for each section, the road width, road state, and other metrics are computed iteratively by processing slices perpendicular to the road. For example, using the default road section length (10 m), a 500m road will be split into 50 sections. [profile_resolution] Default = 0.5 m. The resolution of the profiles and DTMs for metrics measurements (see Figure 6 in the method paper). 5.2 Embankment Parameters: The meaure_roads() function includes one parameter that specifies how the algorithm deals with embankments in the terrain. [min_slope] Default = 10 degrees. Slope (degrees) greater than the min_slope may initiate or terminate the detection of embankments. For example, if a slope of greater than 10 degrees is encountered on the right or the left of the road centerline, the method will consider this point the road edge. This is illustrated in the figure below. Nice slopes and ditches are expected to be detected to delimitate the road. 5.3 Terrain Parameters (excluding embankment): The meaure_roads() function includes two parameters that specify how the algorithm detects road edges in the terrain aspect, excluding embankment/shoulder (see section 5.2 for embankment parameters). The purpose of these parameters is to allow the algorithm to find the edges of the road, even in the absence of embankments. Classifying the edges of roads using embankments is the preferable method. In the absence of clear embankments, defined by the road edge slopes, the method relies on the DTM complexity of each road section (see section 5.1 for information on road sections) to classify the edges of the road. We refer to the classification of road edges using DTM complexity as the “rescue method” as it is used when the preferred method, based on road embankment, is not possible. The assumptions that support the interpretation of DTM complexity to relocate roads is that roads are flat and not complex. If we remove potential slopes that follow the direction of the road, a road is roughly a 2D strip without variations in height (Z). The edges of a road correspond to the natural landscape and are more complex with a 3D structure and variations on the Z axis. On a given slice perpendicular to the road (see section 5.1 for information on road slices), metrics on the ground points from left to right can be computed to assess the road profile. The road profile is expected to have higher values outside the boundaries of the road and lower or close to zero values inside the boundaries of the road. The road profile frequently resembles the shape of a parabola. Adjusting the method parameters determines the thresholds which define road edges, as illustrated in the figure below. [max_sd_ground_points] Default = 0.1. The LiDAR ground points belonging to roads have a low dispersion on Z profiles because roads are relatively flat (refer to Figure 6 in the method paper). Beyond the boundaries of a road, the standard deviation of ground points starts to increase because the terrain is more complex. This value is a threshold at which the edges of the roads are detected with the rescue method. [max_elevation_ground_points] Default = 0.15. The algorithm normalizes the point cloud relative to the road (i.e., the ground points from a road are expected to be at 0, and the surrounding points are expected to be non-zero). The rescue method uses this property to detect road edges. The embankment method (section 5.2) and rescue method are not mutually exclusive. In many cases, an embankment may be detected on only one side of a road, meaning that the rescue method is used to detect the road edge on the other side. Changing terrain parameters is particularly important when the topography is flat. As the reader can see, a road can be detected, using both methods, based on geometrical features. However, when there is almost nothing to detect (i.e., no embankments and no DTM complexity), the algorithm fails and overestimates the road width. In this situation, decreasing the terrain parameter thresholds will lead to a narrowing of the detected road. 5.4 Vegetation: Once the width of the road is determined (see sections 5.2 and 5.3), the method estimates the drivable road width using the parameter max_percentage_drivable. max_percentage_drivable is the total road width minus the vegetation that impedes road passage. The motivation for this parameter is that while the Slope and DTM can be used to locate a road on the landscape, that road may not be drivable due to vegetation growth. All the LiDAR points located on the road are expected to be ground points. To account for inaccuracies, we assume that 100% of the points on the road must be between 0 and 50 cm. If LiDAR points on the road are above 50 cm, there is vegetation on the road. A single point above 50 cm may be an outline, but a significant percentage of points above this value will trigger a stop signal. Starting from the centerline and going to the left and right, the method computes the cumulative percentage of non-ground points on the road. This produces a ‘threshold-like’ road profile for width measurement (see figure below). [max_percentage_drivable] Default = 0.15. The maximum percentage of LiDAR points above 50 cm (explained above). 5.5 Conductivity Parameters: A key component of the measure_roads() method is the development of a conductivity layer, where pixel values indicate the likelihood that a pixel is or is not drivable. Conductivity parameters correspond to the method used to estimate the overall conductivity layer using multiple sub-conductivity layers. Each layer is described in Figure 3 of the method paper and is activated using an activation function. These activation functions have two thresholds; unless otherwise stated. The values below correspond to these thresholds. It is not recommended for users to change the default values of these parameters. [sigma_min] Default = 0.1. The minimum conductivity layer value cannot be lower than this value. The conductivity layer construction is done such as conductivity values can range from 0 to 1. However, very low values (&lt;0.1) are problematic as they may form a gap in the road and result in a false negative (e.g., the gap may be interpreted as an impassible obstacle). Version 0.2.0 of the ALSroads package (not the one described in the method paper, which is 0.1.0) introduced this parameter to allow the method to cross small gaps in the conductivity layer. [s] Default = c(5, 20). The slope (s) of the terrain indicates where a road cannot be. If the slope of the terrain is greater than the max slope, then a road cannot be present. To avoid binary logic and a hard threshold, a second threshold is introduced at 5° to transform the slope map into a sub-conductivity map using a piecewise-linear activation function. A slope of &lt; 5° has a conductivity of 1; between 5° and 20°, the conductivity decreases linearly to 0, making it impossible to move through pixels with steeper slopes. [r] Default = c(0.05, 0.1). The roughness (r) sub-conductivity layer is based on the assumption that a road surface is anticipated to be a smooth surface in a relatively rough environment. [e] Default = 40. This is a simple threshold activation function. [q] Default = c(0.1, 0.5). Intensity range (q) (difference between the maximum and the minimum) as an estimation of the intensity homogeneity. Rather than using the absolute thresholds, which are not applicable broadly with intensity, we use local and auto-adaptive thresholds based on two percentiles of intensity. Here the 10th and 50th percentiles of intensities are used as threshold values for the activation function. [h] Default = c(0.1, 0.2). The CHM can be interpreted to inform gaps in the canopy. Low CHM (h) values are interpreted to indicate the location of a drivable surface. [d] Default = c(0.25, 0.95). Ground point density values cannot be used directly because of their dependence on the local nominative sampling density. Consequently, we opted for auto-adaptive thresholds based on two percentiles of density (d). [alpha] Default list(h = 1, d = 2, r = 1, i = 1). These are the alpha parameters in equation 1 in the method paper. 5.6 Road State Parameters: Using the measure_roads() function, users classify roads into four classes (see section 4.1.3. These classes are determined using four metrics derived from the point cloud (Figure 7 of the method paper): W - the drivable width of the road, P - the percentage of vegetation points between 0.5 and 5 meters above the road, S - the average number of shoulders detected and, σ - the conductivity per linear meter. An activation function is applied to the four metrics. These activation functions have two parameters. The following are the two parameters of each activation function. Modifying these thresholds has predictable behaviours, but it is hard to quantify them. A simple voting system calculates the weight of each metric (W, P, S, and σ) for determining the road Class. For example, if the method detects a large ‘W’ (drivable width), then this is a ‘vote’ towards the road being a Class 1, but if the ‘P’ (vegetation above the road) value for the road is high, then this is a ‘vote’ for the road being a Class 4 because it appears to be abandoned. Meanwhile, the ‘S’ (average number of shoulders) value for the road may indicate that the road has nice ditches and is well-shaped, which is a ‘vote’ towards the road being a Class 1. Interpreting all these ‘Votes’ facilitates the determination of an overall Class for the road; in this example, the road may be classified as a ‘Class 2’ road. [drivable_width_thresholds] Default c(1, 5). Roads with a drivable road width over 5 m are assigned a score of 100. Roads with a width of less than 1 m are assigned a score of 0. There is a linear relationship between 1 and 5 (i.e., a with of 2 m returns a score of 50%). If a user knows that a road of width 4 m is a good road in their context, we recommend changing the parameter, for example, to c(1, 3). [percentage_veg_thresholds] Default = c(10,40). Roads with a percentage of vegetation (point above ground in a range of [0.5m, 5m]) below 10% are assigned a score of 100%. Roads with a percentage greater than 40% are assigned a score of 0%. There is a linear relationship between the lower and upper percentage vegetation thresholds. [shoulder_thresholds] Default = c(50, 75). For each slice of the road (see ‘section_length’ in section 5.1), the algorithm retains the count of the shoulder/embankments found. For each road, it is possible to find 0, 1, or 2 shoulder/embankments. If the algorithm consistently finds two shoulders (one on the left and one on the right) for each road segment, the road is extremely well-shaped, and we have 100% of the possible count. However, in practice, roads are very rarely shaped well enough that two shoulder/embankments per section can be consistently found. This parameter counts the percentage of shoulders found. A shoulder percentage of 0 % means that the algorithm did not find any shoulders at any road section, and the road is likely poor quality, if a road at all. If 100% of the road shoulders are found, the road is well shaped, and the road score is 100%. If under 50 % of the road shoulders are found for the entire road, the road score is 0%. Changing this parameter is advised if users know that the roads in their study area are not well-shaped by strong ditches. Ultimately users may opt to deactivate this parameter, which is not currently possible but could be done on demand. [conductivity_thresholds] Default = c(0.25, 0.5). If the conductivity of the road is too low (&lt; 0.25), the road score is 0% (see section 5.5). If the conductivity is above 0.5, the score is 100%. The road score between these thresholds is linear. We do not recommend changing this threshold because users do not have control of the conductivity layer, and manipulating this parameter would be done blindly. Once the algorithm calculates a score for each of the four road state parameters, these scores are combined into a final score (Figure 7 of the method paper). This score can be used as is but is also binned in four classes where Class 4 corresponds to a score [0, 25], Class 3 to a score [25, 50], Class 2 to a score [50, 75], and Class 1 to a score [75, 100 ]. #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\01\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 12 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 638000 ymin: 5142000 xmax: 639000 ymax: 5143000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `upd_roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\01\\upd_roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 12 features and 28 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 637998.8 ymin: 5142000 xmax: 639000 ymax: 5142999 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `road&#39; from data source `E:\\ALSroads_Guide\\data\\06\\02\\road.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 36 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 451156.3 ymin: 5389576 xmax: 451767.8 ymax: 5389814 #&gt; Projected CRS: NAD83 / UTM zone 17N #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\03\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 36 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 433270.3 ymin: 5336398 xmax: 434000 ymax: 5336992 #&gt; Projected CRS: NAD83 / UTM zone 17N #&gt; Reading layer `upd_roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\03\\upd_roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 45 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 433481 ymin: 5336562 xmax: 434000 ymax: 5336989 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N #&gt; Reading layer `upd_roads_custom&#39; from data source `E:\\ALSroads_Guide\\data\\06\\03\\upd_roads_custom.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 44 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 433275.5 ymin: 5336400 xmax: 434001.2 ymax: 5336989 #&gt; Projected CRS: NAD83 / UTM zone 17N #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\03\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 1 feature and 36 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 433270.3 ymin: 5336398 xmax: 434000 ymax: 5336992 #&gt; Projected CRS: NAD83 / UTM zone 17N #&gt; Reading layer `upd_roads&#39; from data source `E:\\ALSroads_Guide\\data\\06\\04\\upd_roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 8 features and 44 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 433142.5 ymin: 5336329 xmax: 434000.8 ymax: 5337000 #&gt; Projected CRS: NAD83 / UTM zone 17N #&gt; Reading layer `upd_roads_custom&#39; from data source `E:\\ALSroads_Guide\\data\\06\\04\\upd_roads_custom.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 8 features and 44 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 433141.7 ymin: 5336329 xmax: 434000.8 ymax: 5337000 #&gt; Projected CRS: NAD83 / UTM zone 17N #&gt; Reading layer `upd_roads_custom_and_standard&#39; from data source `E:\\ALSroads_Guide\\data\\06\\04\\upd_roads_custom_and_standard.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 16 features and 45 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 433141.7 ymin: 5336329 xmax: 434000.8 ymax: 5337000 #&gt; Projected CRS: NAD83 / UTM zone 17N "],["sec-edge-case-studies.html", "6 Case Studies 6.1 Case Study Structure: 6.2 Case Study 1: Low DTM complexity 6.3 Case Study 2: No Vegetation 6.4 Case Study 3: Narrow/Wide Roads 6.5 Case Study 4: Drivable Width Thresholds", " 6 Case Studies In this section, we present four case studies where the measure_road() standard parameters (see section 5 may require tuning: Case Study 1: Low DTM complexity Case Study 2: No vegetation Case Study 2: Narrow/Wide Roads Case Study 3: Drivable Width Thresholds 6.1 Case Study Structure: For each case study, we include code snippets outlining how to: Read the required input data (refer to section 3 for detailed information). Check the Coordinate Reference System (CRS) of input data and clip the existing road network to the spatial extent of the LAS catalog. Update the existing road network using the measure_roads() function from the ALSroads package. Adjust the standard road extraction parameters to improve method accuracy (see section 5 for information on the standard parameters). Visualize road extraction results. Each case study is ‘stand-alone’, and users do not need to refer to other sections of the user guide. As such, some code snippets, such as loading data, are repeated for each case study. 6.2 Case Study 1: Low DTM complexity 6.2.1 Overview: The road extraction method developed by Roussel et al. (2022) uses the geometry of the terrain to correctly relocate and measure the roads. Under ideal circumstances, a road is expected to be flat with steep slopes on its edges (shoulders or embankments). The road is embedded within an environment and surrounded by complex and non-flat topography. Under these assumptions, a road is not that hard to find and measure. However, problems arise when there is no geometry at all to detect. This may happen, for example, if the roads are not shaped with ditches on their sides. In this case, the algorithm is supposed to work with a “rescue method” (see section 5.3) that does not use the shoulders but instead the terrain complexity. Ultimately, if the terrain is perfectly flat, there are no geometrical features that can be used to detect the road. In the following example, we present a method for adjusting the measure_roads() standard parameters to detect roads in a landscape where the topography is almost perfectly flat, roads are not nicely shaped, and standard road extraction is challenging. As the 3D plot of the ground points demonstrates here, the road is easily identifiable, but there is no geometrical feature that can be used to measure it. The road is flat in a flat environment. las &lt;- readLAS(&quot;data/06/01/road_10462.las&quot;) plot(filter_ground(las), bg = &quot;white&quot;) First let’s have a look at the conductivity layer: sig = ALSroads::rasterize_conductivity(las, dtm_cs1) #&gt; ........ plot(sig, col = viridis::inferno(50)) As we can see the conductivity map is absolutely perfect. Geometrical features are not that important to locate the road. Many other features are used, including the vegetation and the local density of point. Thus the road will be perfectly relocated even if the road is flat in a flat environment. The measurement of the road width is likely to fail because of the absence of clear geometry. Below we can see one slice of the point cloud perpendicularly to the road. For a better understanding of the figure users should refer to section 5. What matters here are the red and green arrows that represent the total road width and the drivable width, respectively. Clearly this road is not 21 m wide. The reason the algorithm fails is because everything is perfectly flat and there is nothing to constrain the road width. By altering the default measure_roads() parameter to be more aggressive and much less tolerant to various sources of noise we can relocate the road more accurately. In this specific slice, 6 m is probably a bit narrow for the true road width. Users must remember that measurements are performed on numerous consecutive slices and averaged (see section 5.1 for information on road slices). For this specific road, the default parameters result in the road being classified as a 13.6 mwide (total width) Class 2 road. Once the parameters are adjusted the road is classified as a 7.6 m(total width) Class 1 road. The custom parameters result in a road width and the Class that are are more representative of the real road. If the method classifies the road width as 13.6 m, many points will be found above the ground (i.e., vegetation). This interpretation impacts the road classification (see section 5.6) as the method assesses the road as having vegetation on it. However, if the true road width is only 7.6 m then the algorithm will not find vegetation on the road, as this vegetation is beyond the road edge boundaries, and the road will determined to be a very clean Class 1 road. Turning the `measure_roads()` on a road-by-road basis is not possible or suitable for updateing extensive forest road networks. Doing so would defeat the purpose of the method, which is to automatically update road networks. Instead of turning parameters to suit individual roads, users should tune parameters by landscape. In this case study, the custom parameters work well, but generally the default parameters are optimal. It is important to remember that this is an edge case and represents and extreme scenario. 6.2.2 Data, Method, and Application: In the follow sections, example code and method implementation for the adjustment of parameters in a low DTM complexity case study is presented. 6.2.3 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.2.3.1 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.2.3.2 Parameter Tuning The measure_roads() terrain parameters dictate how the method handles DTM complexity (see section 5.3). The standard terrain parameters are: max_elevation_ground_points: Default = 0.1 max_sd_ground_points: Default = 0.15 In a low DTM complexity area decreasing the max_elevation_ground_points and max_sd_ground_points improves the accuracy of road extraction. In this case study we decrees the max_elevation_ground_points to 0.07 and decrees the max_sd_ground_points to 0.04. custom_param = alsroads_default_parameters custom_param$terrain$max_elevation_ground_points = 0.07 custom_param$terrain$max_sd_ground_points = 0.04 updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, param = custom_param) 6.2.4 Results: Plotting the updated road network alongside the existing road network allows the visualization of the updated roads. 6.3 Case Study 2: No Vegetation 6.3.1 Overview: The road extraction method developed by Roussel et al. (2022) uses road edge vegetation to correctly position the updated road. There are three possible vegetation scenarios: 1) the road is nicely shaped by vegetation and the algorithm can accurately update the road, 2) DTM is very flat and locating the road is a challenge (see Case Study 1: Low DTM complexity), or 3) the road is not highlighted enough compared to the surrounding vegetation and cannot be located. The example case study roads are located in the northern portion of the Romeo Malette Forest, in the province of Ontario. #las_cs2 &lt;- readLAS(&quot;data/06/02/ctg/1kmZ174510538902018L.laz&quot;) #las_c &lt;- clip_circle(las_cs2, 451400, 5389750, 500) #plot(las_c, bg = &quot;white&quot;, size = 3) #add_dtm3d(x, dtm_cs2) 6.3.2 Data, Method, and Application: 6.3.2.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.3.2.2 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.3.2.3 Parameter Tuning: custom_param = alsroads_default_parameters custom_param$state$drivable_width_thresholds = c(3, 8) updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, param = custom_param) 6.3.3 Results: Plotting the updated road network alongside the existing road network allows the visualization of the updated roads. 6.4 Case Study 3: Narrow/Wide Roads 6.4.1 Overview: The road extraction method developed by Roussel et al. (2022) updated an existing road network by searching within a buffer area of the existing road for an updated road line. The algorithm processes only the point cloud within the buffer around the reference roads (see section 5.1). This value corresponds to the biggest road offset error (i.e., how incorrect the existing road track is) that can be fixed by the method. In some circumstances users may know that the updated is beyond the standard road buffer distance (80 m) and tune the road_buffer parameter accordingly. Similar, if a user knows that the maximum road track error is less than the standard buffer theroad_buffercan be reduced to increase accuracy and reduce computation. In this case study we demonstrate how users can tune measure_roads parameters in an area where the updated road is very close to the existing road. The example case study roads are located in the eastern portion of the Romeo Malette Forest, located in the province of Ontario. 6.4.2 Data, Method, and Application: 6.4.2.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.4.2.2 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.4.2.3 Parameter Tuning: The measure_roads() extraction parameters include a parameter called road_buffer for defining the road buffer width (see section 5.1). The default road_buffer distance is 80 m, but in this case study we know that the updated road is &lt; 10 m from the existing road network. In this case study we decrees the road_buffer to 40 m custom_param = alsroads_default_parameters custom_param$extraction$road_buffer = 40 updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, param = custom_param) 6.4.3 Results: In this case study adjusting the road_buffer distance impacted the location road centerline. By comparing the 1) existing road network, 2) updated road using an 80 m buffer (the default value), and 3) the updated road using an 40 m buffer we can see that the road centerline location has altered: 6.5 Case Study 4: Drivable Width Thresholds 6.5.1 Overview: The road extraction method developed by Roussel et al. (2022) updates an existing road network by assigning a Class (1-4), which indicates the road stare, to each road. The class is defined by assessing several road state parameters (see 5.6). It is not recommended for users to edit the road state parameters unless specifically required. For example, users may have a specific value for defining the drivable_width_thresholds of a road that exceeds the measure_roads() default thresholds (c(1, 5)). In some circumstances users may know that the drivable width of a road is more or less than the standard thresholds and may tine the drivable_width_threshold accordinginly. In this case study we demonstrate how users can tune measure_roads() parameters in an area where the the drivable_width_thresholds of roads exceed the standard parameters. The example case study roads are located in the eastern portion of the Nipissing Forest, in the province of Ontario. 6.5.2 Data, Method, and Application: 6.5.2.1 Required R Packages: remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) #Install the ALSroads Package library(&quot;ALSroads&quot;) library(&quot;lidR&quot;) library(&quot;raster&quot;) library(&quot;sf&quot;) library(&quot;ggplot2&quot;) 6.5.2.2 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld-keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 6.5.2.3 Parameter Tuning: The measure_roads() road state parameters include a parameter called drivable_width_thresholds for assigning drivable width thresholds (see section 5.6). The default drivable_width_thresholdsare c(1, 5), but in this case study we know roads under 3 m are not drivable, and roads over 8 m are good roads. We set the drivable_width_thresholds to c(5, 8) meaning that roads with drivable widths over 8 m are assigned a score of 100 and roads with a width less than 5 m are assigned a score of 0 (there is a linear relationship between 5 and 8 m). custom_param = alsroads_default_parameters custom_param$state$drivable_width_thresholds = c(5, 8) updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, param = custom_param) 6.5.3 Results: Results show that when the drivable_width_thresholds is changed to c(5, 8) fewer roads are classified as Class 1 and Class 2 (i.e., drivable roads). Compared to the updated road network using standard parameters, where no roads were Class 3 or 4, the updated road network using custom parameters includes two roads of Class 3 (i.e., not drivable). These results demonstrate that changing the drivable_width_thresholds impacts the road Class by considering roads beyond the minimum road width threshold, in this case 5 m, as not drivable. Note: In this case study area there are no Class 4 roads. ggplot(upd_rds_custom_and_standard_cs4, aes(factor(CLASS))) + geom_bar(aes(fill = Param), position = &quot;dodge&quot;, stat=&quot;count&quot;, width= 0.5) + theme_minimal() + theme(legend.position=&quot;bottom&quot;) + scale_fill_discrete(name=NULL, labels = c(&quot;Custom Parameters&quot;, &quot;Standard Parameters&quot;)) + labs(y = &quot;Count&quot;, x = &quot;Road Class&quot;) "],["sec-waterbodies.html", "7 Waterbodies 7.1 Example 1: Road Extraction without Waterbodies 7.2 Example 2: Road Extraction with Waterbodies 7.3 Comparison", " 7 Waterbodies The inclusion of water bodies when using the measure_roads() function is recommenced for several reasons, as explained in section /@ref(). Here, we provide two road extraction examples for the same study areas. In the first example water bodies are not included as a measure_roads() parameter, in the second example water bodies are included. We therefore demonstrate the value of using water bodies with the measure_roads() function. 7.1 Example 1: Road Extraction without Waterbodies 7.1.1 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld -keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 7.1.2 Updating Roads updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm) 7.2 Example 2: Road Extraction with Waterbodies 7.2.1 Loading Data: ctg &lt;- readLAScatalog&quot;path/to/ctg/files&quot;, filter = &quot;-drop_withheld -keep_random_fraction 0.25&quot;) dtm &lt;- raster(&quot;path/to/dtm.tif&quot;) roads &lt;- st_read(&quot;path/to/roads&quot;) waterbodies &lt;- st_read(&quot;path/to/waterbodies&quot;) st_crs(roads) = st_crs(ctg) roads = sf::st_crop(roads, ctg) 7.2.2 Updating Roads updated_roads_custom_param &lt;- measure_roads(ctg = ctg, roads = roads, dtm = dtm, water = water) 7.3 Comparison #&gt; Reading layer `roads&#39; from data source `E:\\ALSroads_Guide\\data\\03\\roads.shp&#39; using driver `ESRI Shapefile&#39; #&gt; Simple feature collection with 23 features and 20 fields #&gt; Geometry type: LINESTRING #&gt; Dimension: XY #&gt; Bounding box: xmin: 570000 ymin: 5151000 xmax: 573000 ymax: 5154000 #&gt; Projected CRS: NAD83(CSRS) / UTM zone 17N "],["sec-tips-and-tricks.html", "8 Tips and Tricks 8.1 Casting Roads to Linestring 8.2 Adding an ID Column 8.3 Selecting Specific Roads 8.4 Plotting Data 8.5 Saving Data 8.6 Reconnecing Roads", " 8 Tips and Tricks Following the update of road segments using the ALSroadspackage users may wish to edit data, filter results, or plot outcomes. Here, we provide code snippets intended to provide users with some basic data manipulation and interpretation tools. 8.1 Casting Roads to Linestring Existing road networks may be multistring features, the measure_roads() function requires that roads are linestrings. Changing multistring features to linestrings requires the st_cast() function from the sf package (refer to the sf vignette for detailed information). roads &lt;- st_cast(roads, &quot;LINESTRING&quot;) 8.2 Adding an ID Column Existing road networks frequently include FID and ID columns that will help users select individual roads. In some cases, however, road networks have been edited or updated and the ID/FID columns are missing information. Users may wish to add a new ID column that specifically relate to the roads on which the ALSroads method was applied. In that case, users can add and populate a new column using the rowid_to_column from the tibble package (refer to the tibble vignette for detailed information). roads &lt;- tibble::rowid_to_column(roads, &quot;NUM&quot;) 8.3 Selecting Specific Roads road_subset &lt;- roads %&gt;% dplyr::filter(NUM %in% c(0:10)) 8.4 Plotting Data 8.5 Saving Data 8.6 Reconnecing Roads #&gt; &lt;STYLE type=&#39;text/css&#39; scoped&gt; #&gt; PRE.fansi SPAN {padding-top: .25em; padding-bottom: .25em}; #&gt; &lt;/STYLE&gt; "],["sec-getting-started-with-r.html", "9 Getting Started with R 9.1 Installing R and RStudio 9.2 Installing ALSroads", " 9 Getting Started with R 9.1 Installing R and RStudio ALSroads is an R package and requires an installation of the R programming language that can be downloaded for Windows, macOS, and Linux. The R language is usually used using an integrated development environment (IDE). RStudio is the most famous IDE for R and is available for download online. Several tutorials detailing the initial setup and introduction to R are available online: An Introduction to R Introduction to Data Science R Tutorial: a quick beginner’s guide to using R R Packages: A Beginner’s Tutorial 9.2 Installing ALSroads ALSroads is available on Github but is not part of the available packages on CRAN. To install ALSroads, you must first install the package remotes and then use remotes to install the ALSroads package from Github. install.packages(&quot;remotes&quot;) remotes::install_github(&quot;Jean-Romain/ALSroads&quot;) "],["sec-team.html", "10 Project Team Members", " 10 Project Team Members ALSroads was developed by Jean-Romain Roussel for road extraction in forested regions and has been tested and validated in Quebec and Ontario. A comprehensive explanation of the road extraction method is available in Roussel et al. (2022), as well as results from the method implementation in Quebec. The method has been validated for two forest management units in Ontario. The development and testing of the road extraction method and the ALSroads package would not be possible without dedicated collaborators. Jean-Romain Roussel [Method Author and Developer] Ilythia D. Morley [Project Coordinator] is the project coordinator for this project to facilitate communication, data transfers, and product testing. Professor Nicholas Coops [Project Lead] holds a Canada Research Chair in Remote Sensing (Tier 1) at UBC. He has published &gt;460 total referenced peer-reviewed journal publications and is internationally recognized as a scientific leader in the field of remote sensing. He was the principal investigator of the AWARE project; a 5-year research project focused on developing LIDAR applications in Canada for forestry applications. He is a co-author on the Canadian Forest Service LIDAR best practice guide series, the most downloaded CFS information handbook ever, focused on LIDAR data processing. In 2020, he was the co-receipt of the Marcus Wallenberg prize for scientific achievements contributing to significantly broadening knowledge and technical development within the field of Forestry. Professor Alexis Achim [Project Lead] is the Director of Laval University’s Renewable Materials Research Centre. He has developed expertise in the field of wood resource assessment and participated in AWARE, a Canada-wide project on using ALS to predict wood fibre resource attributes. The R package ‘lidR’, which is extensively used in the ALS international research community, was developed in his lab as part of the work done for this project. He is currently a lead investigator of a new 5-year, $CAD 5 million research project (Silva21) developing new silvicultural approaches and technologies for the Canadian Forest industries. Antoine Leboeuf [Team Member] Ministère des Forêts, de la Faune et des Parcs (MFFP) Jean-Francois Bourdon [Team Member] Ministère des Forêts, de la Faune et des Parcs (MFFP) Professor Jeff Dech [Team Member] is chair of the Department of Biology and Chemistry at Nipissing University. He previously held an Industrial Research Chair in Forest Bioproducts supported by Tembec and was a co-investigator on the AWARE project. He has developed a research program focused on the use of site classification and stand structure data derived from remote sensing to describe and predict forest growth and quality over broad spatial scales. This work has focused on Ecological Land Classification and LiDAR-derived predictors and has involved the establishment of extensive networks of field plots and intensive sampling campaigns as part of several collaborative projects in the Boreal and Great-Lakes St. Lawrence forests. Douglas E.B. Reid [Team Member] is the Boreal Silviculture Research Program Lead at the Centre for Northern Forest Ecosystem Research in Thunder Bay. His research has developed tools to evaluate the accuracy of remote sensing approaches to silviculture monitoring and is developing tools to evaluate stand height as a measure of growth performance in regenerating stands using single photon LiDAR. He has knowledge of the importance of roads and their extreme variability from conducting previous work examining caribou habitat conditions within managed and unmanaged forests in Ontario. Mr. Grant McCartney [Team Member] is an analyst at Forsite, and formally acted as a spatial analyst and forest information systems coordinator with Rayonier Advanced Materials (RYAM) Forest Management. He performs spatial analysis in support of forest management planning (FMP) and forestry operations on the Gordon Cosens, Romeo Malette and Martel – Magpie Forests in Northeastern Ontario, Canada. Grant is a member of the Forest Information Data Advisory Group (FIDAG) and Provincial Forest Inventory Advisory Committee (PFIAC) MNRF committees working to improve the quality of spatial forest information in the province. Scott McPherson [Team Member] is the planning forester and analyst for the Nipissing and Sudbury Forests of central Ontario, reporting to Nipissing Forest Resource Management Inc and the Vermilion Forest Management Company, Ltd. Scott has worked in the government and industry sectors for 25 years, focusing on growth &amp; Yield, silviculture, and planning. Lauren Quist [Team Member] is an analyst and planner at Hearst Forest Management Inc and formally worked as a contractor for the MNFR. Lauren assists in preparing 10-year forest management plans is a certified Photo-Interpreter for the Boreal Forest and Great Lakes - St.L. Forest and works with FRI and LiDAR data to produce timber volume estimates. In her current role, Lauren’s responsibilities include producing FSC documentation &amp; products (e.g. update Gap Analysis, HCV, caribou strategy), caribou habitat &amp; disturbance analysis, and the preparation of annual forest management reports. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
